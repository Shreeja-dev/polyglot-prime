<channel version="4.5.0">
  <id>fc36c056-84bc-4f0a-9a71-f5c1c32c5941</id>
  <nextMetaDataId>2</nextMetaDataId>
  <name>FlatFileCsvBundleValidate</name>
  <description></description>
  <revision>29</revision>
  <sourceConnector version="4.5.0">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.http.HttpReceiverProperties" version="4.5.0">
      <pluginProperties>
        <com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties version="4.5.0">
  <authType>NONE</authType>
        </com.mirth.connect.plugins.httpauth.NoneHttpAuthProperties>
      </pluginProperties>
      <listenerConnectorProperties version="4.5.0">
        <host>0.0.0.0</host>
        <port>1222</port>
      </listenerConnectorProperties>
      <sourceConnectorProperties version="4.5.0">
        <responseVariable>finalResponse</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
      <xmlBody>false</xmlBody>
      <parseMultipart>true</parseMultipart>
      <includeMetadata>false</includeMetadata>
      <binaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*|application/zip</binaryMimeTypes>
      <binaryMimeTypesRegex>true</binaryMimeTypesRegex>
      <responseContentType>text/plain</responseContentType>
      <responseDataTypeBinary>false</responseDataTypeBinary>
      <responseStatusCode>201</responseStatusCode>
      <responseHeaders class="linked-hash-map"/>
      <responseHeadersVariable></responseHeadersVariable>
      <useResponseHeadersVariable>false</useResponseHeadersVariable>
      <charset>DEFAULT_ENCODING</charset>
      <contextPath>/flatfile/csv/Bundle/$validate/</contextPath>
      <timeout>30000</timeout>
      <staticResources/>
    </properties>
    <transformer version="4.5.0">
      <elements>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="4.5.0">
          <name>Step1 : Store File To Inbound Folder</name>
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <script>var File = Packages.java.io.File;
var FileOutputStream = Packages.java.io.FileOutputStream;
var FileInputStream = Packages.java.io.FileInputStream;
var ZipFile = Packages.java.util.zip.ZipFile;
var ZipEntry = Packages.java.util.zip.ZipEntry;
var BufferedOutputStream = Packages.java.io.BufferedOutputStream;
var ObjectMapper = Packages.com.fasterxml.jackson.databind.ObjectMapper;
var JavaTimeModule = Packages.com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
var mapper = new ObjectMapper();
mapper.registerModule(new JavaTimeModule()); 

logger.info(&quot;Fetching AppConfig from Global Map&quot;);
var tenantId = $(&apos;headers&apos;).getHeader(&apos;X-TechBD-Tenant-ID&apos;);
var fhirProfileUrlHeader = $(&apos;headers&apos;).getHeader(&quot;FHIR-STRUCT-DEFN-PROFILE-URI&quot;);
var zipFileInteractionId = java.util.UUID.randomUUID().toString();
var requestParameters = getRequestParameters();
var inboundFolder = &quot;D:/techbyDesign/flatFile/inbound/&quot;; // TODO-move to environment variable
var ingressFolder = &quot;D:/techbyDesign/flatFile/ingress/&quot;+zipFileInteractionId+&quot;/ingress&quot;; // TODO-move to environment variable&apos;
var pythonPackageFullPath = &quot;D:/techbyDesign/specification/datapackage-nyher-fhir-ig-equivalent.json&quot;
var pythonScriptFullPath =&quot;D:/techbyDesign/specification/validate-nyher-fhir-ig-equivalent.py&quot;;
var uploadedFileFullPath = uploadFileToInboundFolder(inboundFolder);
extractZipFile(uploadedFileFullPath,ingressFolder);
var csvFiles = getCsvFilesFromDirectory(ingressFolder); //TODO - non csv files to be listed as not-processed
copyFileToFolder(pythonPackageFullPath,ingressFolder);
copyFileToFolder(pythonScriptFullPath,ingressFolder);
logger.info(&quot;Invoke validation - BEGIN&quot;);
var file = createMultipartFile();
logger.info(&quot;multi part file created &quot; + file);
saveArchiveInteraction(zipFileInteractionId, file); //TODO - implement the saving
var validationResults = invokeValidation(zipFileInteractionId, file,csvFiles,tenantId,requestParameters);
var validationResultsJson = convertMapToJson(validationResults);
responseMap.put(&quot;finalResponse&quot;, validationResultsJson);
logger.info(&quot;Invoke validation - END&quot;);
return;

function convertMapToJson(map) {
    return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(map);
}

function saveArchiveInteraction(zipFileInteractionId, file){
	//TODO - CHECK AND IMPLEMENT  CsvService:saveArchiveInteraction
	
}
function copyFileToFolder(sourcePath, destinationFolderPath) {
    var Files = Packages.java.nio.file.Files;
    var Paths = Packages.java.nio.file.Paths;
    var StandardCopyOption = Packages.java.nio.file.StandardCopyOption;

    try {
        var source = Paths.get(sourcePath);
        var destinationFolder = Paths.get(destinationFolderPath);

        // Ensure destination folder exists
        if (!Files.exists(destinationFolder)) {
            Files.createDirectories(destinationFolder); // Create the directory if it doesn&apos;t exist
        }

        // Extract filename from sourcePath
        var fileName = source.getFileName();
        var destinationPath = destinationFolder.resolve(fileName); // Append filename to folder path

        // Copy file to the folder
        Files.copy(source, destinationPath, StandardCopyOption.REPLACE_EXISTING);

        return &quot;File copied successfully to: &quot; + destinationPath.toString();
    } catch (e) {
        return &quot;Error copying file: &quot; + e.message;
    }
}


function getCsvFilesFromDirectory(folderPath) {
    var File = Packages.java.io.File;
    var Arrays = Packages.java.util.Arrays;
    var ArrayList = Packages.java.util.ArrayList;

    var folder = new File(folderPath);
    var fileList = new ArrayList();

    if (folder.exists() &amp;&amp; folder.isDirectory()) {
        var files = folder.listFiles();
        if (files !== null) {
            for (var i = 0; i &lt; files.length; i++) {
                if (files[i].isFile() &amp;&amp; files[i].getName().toLowerCase().endsWith(&quot;.csv&quot;)) {
                    fileList.add(files[i].getAbsolutePath());
                }
            }
        }
    }
    return fileList;
}

function invokeValidation(zipFileInteractionId, file,csvFiles,tenantId,requestParameters){
	
	logger.info(&quot;invokeValidation &quot; + tenantId);
	var engine = new Packages.org.techbd.orchestrate.csv.CsvOrchestrationEngine();
	var appConfig = globalMap.get(&quot;appConfig&quot;);
	var vfsCoreService = new Packages.org.techbd.service.VfsCoreService();
	engine.setAppConfig(appConfig);	
	logger.info(&quot;vfscoreservice&quot;+vfsCoreService);
	engine.setVfsCoreService(vfsCoreService);
	engine.setRequestParamters(requestParameters);
     var session = engine.session()
         .withMasterInteractionId(zipFileInteractionId)
         .withSessionId(java.util.UUID.randomUUID().toString())
         .withTenantId(tenantId)
         .withGenerateBundle(true)
         .withCsvFileList(csvFiles)
         .withFile(file)
         .build();
     logger.info(&quot;session created &quot;);    
     engine.orchestrate(session);
       logger.info(&quot;after orchestration &quot;);    
     return session.getValidationResults();

}
function createMultipartFile() {
    logger.info(&quot;createMultipartFile -BEGIN &quot;);
    var fileContent  = getUploadedFileContent(connectorMessage);
    var fileName = getUploadedFileName(connectorMessage);

    if (!fileContent) {
        logger.error(&quot;File content is empty or undefined!&quot;);
        return null;
    }

    var MultipartFile = function(fileContent, fileName) {
        this.fileContent = fileContent;
        this.fileName = fileName;

        this.getName = function() {
            return fileName;
        };

        this.getOriginalFilename = function() {
            return fileName;
        };

        this.getSize = function() {
            return fileContent.length;
        };

        this.getBytes = function() {
            return fileContent;
        };

        this.getInputStream = function() {
            var ByteArrayInputStream = Packages.java.io.ByteArrayInputStream;
            return new ByteArrayInputStream(fileContent);
        };

        this.transferTo = function(destinationFile) {
            var FileOutputStream = Packages.java.io.FileOutputStream;
            var outputStream = new FileOutputStream(destinationFile);
            outputStream.write(fileContent);
            outputStream.close();
        };
    };
    var file = new MultipartFile(fileContent, fileName);
    logger.info(&quot;MultipartFileCreated successfully &quot;+file);
    return file;
}

function getUploadedFileName(connectorMessage) {
    var rawData = connectorMessage.getRawData();
    var filenameMatch = rawData.match(/filename=&quot;([^&quot;]+)&quot;/);
    var uploadedFileName = &quot;unknown.zip&quot;;
    if (filenameMatch &amp;&amp; filenameMatch[1]) {
        uploadedFileName = filenameMatch[1];
    }
    return uploadedFileName;
}

function getUploadedFileContent(connectorMessage) {
    try {
        var rawData = connectorMessage.getRawData();
        if (rawData) {
            return rawData.getBytes(&quot;ISO-8859-1&quot;);
        } else {
            logger.error(&quot;Raw data is undefined or null.&quot;);
            return null;
        }
    } catch (e) {
        logger.error(&quot;Error extracting file content: &quot; + e.message);
        return null;
    }
}
function getRequestParameters() {
    var requestParameters = new Packages.java.util.HashMap();
    var userAgent = &quot;testuseragent&quot;; //TODO - READ FROM CHANNEL MAP /GLOBAL MAP /REQUEST HEADERS
    var requestUri = &quot;/flatfile/csv/Bundle/$validate&quot;; //TODO - READ FROM CHANNEL MAP /GLOBAL MAP /REQUEST HEADERS
    requestParameters.put(&quot;User-Agent&quot;, userAgent);
    requestParameters.put(&quot;Request-Uri&quot;, requestUri);
    return requestParameters;
}

function uploadFileToInboundFolder(uploadFolderPath) {
	try {
		logger.info(&quot;uploadFileToInboundFolder&quot;);
	    var uploadedFileName = getUploadedFileName(connectorMessage);
	    logger.info(&quot;uploadedFileName&quot;+uploadedFileName);
	    var uploadedFileFullPath  = uploadFolderPath+uploadedFileName;
	    // Ensure the upload folder exists and grant write permission if it does not
	    logger.info(&quot;uploadedFileFullPath&quot;+uploadedFileFullPath);
	    var uploadFolder = new File(uploadFolderPath);
	    if (!uploadFolder.exists()) {
	        logger.info(&quot;Upload folder does not exist. Creating it...&quot;);
	        uploadFolder.mkdirs();
	        logger.info(&quot;Upload folder created: &quot; + uploadFolderPath);
	    }
	    uploadFolder.setWritable(true);
	    logger.info(&quot;Write permission granted to the upload folder.&quot;);
	
	    // Step 1: Save the Uploaded File
	    var binaryContent = connectorMessage.getRawData().getBytes(&quot;ISO-8859-1&quot;);
	    if (!binaryContent || binaryContent.length === 0) {
	        logger.error(&quot;No valid ZIP file found in the uploaded data.&quot;);
	        throw new Error(&quot;Failed to extract ZIP file from input data.&quot;);
	    }
	    logger.info(&quot;Starting to save uploaded ZIP file...&quot;);
	    var uploadedFile = new File(uploadedFileFullPath);
	    var fileOutputStream = new FileOutputStream(uploadedFile);
	    fileOutputStream.write(binaryContent);
	    fileOutputStream.close();
	    logger.info(&quot;Successfully saved uploaded file to: &quot; + uploadedFileFullPath);
		return uploadedFileFullPath;
	} catch (e) {
	    logger.error(&quot;Error during ZIP file processing: &quot; + e.message);
	    throw e;
	}
}

function extractFileContent() {
	try {
		var rawPayload = connectorMessage.getRawData();
		var boundary = rawPayload.split(&quot;\r\n&quot;)[0]; // Get the boundary string from the first line

		// Split the payload using the boundary string. This should create an array like:
		// [ &quot;&quot;, &quot;\r\nContent-Disposition: ...\r\n\r\nPK BINARYDATA\r\n&quot;, &quot;--&quot; ]
		var parts = rawPayload.split(boundary);

		// Check that we have at least one part with content
		if (parts.length &gt;= 2) {
		    // parts[1] contains the headers and the binary content. Trim any extra whitespace.
		    var partContent = parts[1].trim();

		    // The headers end at the first blank line, i.e. after &quot;\r\n\r\n&quot;
		    var headerBodySeparator = &quot;\r\n\r\n&quot;;
		    var headerEndIndex = partContent.indexOf(headerBodySeparator);

		    if (headerEndIndex !== -1) {
		        // The binary data starts after the headers and the blank line.
		        var binaryData = partContent.substring(headerEndIndex + headerBodySeparator.length);

		        // Sometimes there might be an extra trailing boundary marker (e.g. ending with &quot;--&quot;)
		        // Remove it if present.
		        if (binaryData.endsWith(&quot;--&quot;)) {
		            binaryData = binaryData.substring(0, binaryData.length - 2).trim();
		        }

		        // At this point, binaryData contains only the binary data.
		        logger.info(&quot;Extracted binary data: &quot; + binaryData);
		    } else {
		        logger.error(&quot;Header separator not found in the payload.&quot;);
		    }
		} else {
		    logger.error(&quot;Payload does not contain the expected parts.&quot;);
		}
		return binaryData;

	} catch (e) {
		// Log any errors that occur during execution.
		logger.error(&quot;Error in sendFlatfileCsv function: &quot; + e);
	}
}

function extractZipFile(zipFilePath, outputFolderPath) {
    var zipFile = new File(zipFilePath);
    var outputFolder = new File(outputFolderPath);

    logger.info(&quot;ZIP File Path: &quot; + zipFilePath);
    logger.info(&quot;Output Folder Path: &quot; + outputFolderPath);

    // Ensure output folder exists
    if (!outputFolder.exists()) {
        logger.info(&quot;Output folder does not exist. Creating it...&quot;);
        outputFolder.mkdirs();
        logger.info(&quot;Output folder created: &quot; + outputFolderPath);
    }
    outputFolder.setWritable(true);
    if (!zipFile.exists() || zipFile.length() === 0) {
        logger.error(&quot;The ZIP file does not exist or is empty.&quot;);
        throw new Error(&quot;ZIP file is missing or empty.&quot;);
    }
    logger.info(&quot;Size of the uploaded file: &quot; + zipFile.length() + &quot; bytes.&quot;);
    var extractionDone = false;

    try {
        // Use ZipFile for handling extraction
        var javaZipFile = new ZipFile(zipFile);
        var entries = javaZipFile.entries();

        // Check if entries are present
        var entryCount = 0;
        while (entries.hasMoreElements()) {
            entries.nextElement();
            entryCount++;
        }
        logger.info(&quot;Found &quot; + entryCount + &quot; entries in the ZIP file.&quot;);

        if (entryCount === 0) {
            javaZipFile.close();
            logger.error(&quot;ZIP file contains no entries.&quot;);
            throw new Error(&quot;ZIP file contains no entries.&quot;);
        }

        // Reset the entries enumeration to start extraction
        entries = javaZipFile.entries();
        logger.info(&quot;Starting extraction process...&quot;);

        // Loop through entries and extract them
        while (entries.hasMoreElements()) {
            var entry = entries.nextElement();
            logger.info(&quot;Found ZIP entry: &quot; + entry.getName());

            // Handle directories
            if (entry.isDirectory()) {
                var newDir = new File(outputFolderPath, entry.getName());
                if (!newDir.exists()) {
                    newDir.mkdirs();
                    logger.info(&quot;Created directory: &quot; + newDir.getAbsolutePath());
                }
            } else {
                // Handle files
                var newFile = new File(outputFolderPath, entry.getName());
                var parentDir = newFile.getParentFile();
                if (!parentDir.exists()) {
                    parentDir.mkdirs();
                    logger.info(&quot;Created parent directory: &quot; + parentDir.getAbsolutePath());
                }

                // Extract file content
                var inputStream = javaZipFile.getInputStream(entry);
                var buffer = new java.lang.reflect.Array.newInstance(java.lang.Byte.TYPE, 4096);
                var bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(newFile));

                var bytesRead;
                while ((bytesRead = inputStream.read(buffer)) !== -1) {
                    bufferedOutputStream.write(buffer, 0, bytesRead);
                }

                bufferedOutputStream.close();
                inputStream.close();
                logger.info(&quot;Extracted file: &quot; + newFile.getAbsolutePath());
            }
        }

        // Mark extraction as complete
        extractionDone = true;
        javaZipFile.close();
        logger.info(&quot;All ZIP entries have been extracted successfully.&quot;);
    } catch (e) {
        // Log only actual errors and not expected scenarios (like no entries in the ZIP)
        if (e.message !== &quot;ZIP file contains no entries.&quot;) {
            logger.error(&quot;Error during ZIP file extraction: &quot; + e.message);
        }
        throw e;
    }

    // Prevent second logging after extraction
    if (!extractionDone) {
        logger.error(&quot;Extraction failed or no entries found.&quot;);
    }
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
      </elements>
      <inboundTemplate encoding="base64"></inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>XML</inboundDataType>
      <outboundDataType>RAW</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.xml.XMLDataTypeProperties" version="4.5.0">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.xml.XMLSerializationProperties" version="4.5.0">
          <stripNamespaces>false</stripNamespaces>
        </serializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.xml.XMLBatchProperties" version="4.5.0">
          <splitType>Element_Name</splitType>
          <elementName></elementName>
          <level>1</level>
          <query></query>
          <batchScript></batchScript>
        </batchProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.0">
        <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.0">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </outboundProperties>
    </transformer>
    <filter version="4.5.0">
      <elements/>
    </filter>
    <transportName>HTTP Listener</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="4.5.0">
      <metaDataId>1</metaDataId>
      <name>Destination 1</name>
      <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="4.5.0">
        <pluginProperties/>
        <destinationConnectorProperties version="4.5.0">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <channelId>none</channelId>
        <channelTemplate>${message.encodedData}</channelTemplate>
        <mapVariables/>
      </properties>
      <transformer version="4.5.0">
        <elements/>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.0">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.0">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.0">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.0">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="4.5.0">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.0">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.0">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="4.5.0">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="4.5.0">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="4.5.0">
        <elements/>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="4.5.0">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>DEVELOPMENT</messageStorageMode>
    <encryptData>false</encryptData>
    <encryptAttachments>false</encryptAttachments>
    <encryptCustomMetaData>false</encryptCustomMetaData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>true</storeAttachments>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="4.5.0">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>true</enabled>
      <lastModified>
        <time>1740049486786</time>
        <timezone>Asia/Calcutta</timezone>
      </lastModified>
      <pruningSettings>
        <archiveEnabled>true</archiveEnabled>
        <pruneErroredMessages>false</pruneErroredMessages>
      </pruningSettings>
      <userId>1</userId>
    </metadata>
  </exportData>
</channel>